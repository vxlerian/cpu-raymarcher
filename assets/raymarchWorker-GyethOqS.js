(function(){"use strict";var z=typeof Float32Array<"u"?Float32Array:Array;function Y(){var r=new z(9);return z!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[5]=0,r[6]=0,r[7]=0),r[0]=1,r[4]=1,r[8]=1,r}function $(r,t){return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[4],r[4]=t[5],r[5]=t[6],r[6]=t[8],r[7]=t[9],r[8]=t[10],r}function N(){var r=new z(16);return z!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=0,r[12]=0,r[13]=0,r[14]=0),r[0]=1,r[5]=1,r[10]=1,r[15]=1,r}function st(r,t){return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3],r[4]=t[4],r[5]=t[5],r[6]=t[6],r[7]=t[7],r[8]=t[8],r[9]=t[9],r[10]=t[10],r[11]=t[11],r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15],r}function B(r,t){var e=t[0],s=t[1],i=t[2],n=t[3],c=t[4],a=t[5],h=t[6],m=t[7],o=t[8],l=t[9],f=t[10],x=t[11],u=t[12],g=t[13],S=t[14],p=t[15],P=e*a-s*c,D=e*h-i*c,A=e*m-n*c,y=s*h-i*a,M=s*m-n*a,R=i*m-n*h,b=o*g-l*u,C=o*S-f*u,L=o*p-x*u,k=l*S-f*g,X=l*p-x*g,q=f*p-x*S,T=P*q-D*X+A*k+y*L-M*C+R*b;return T?(T=1/T,r[0]=(a*q-h*X+m*k)*T,r[1]=(i*X-s*q-n*k)*T,r[2]=(g*R-S*M+p*y)*T,r[3]=(f*M-l*R-x*y)*T,r[4]=(h*L-c*q-m*C)*T,r[5]=(e*q-i*L+n*C)*T,r[6]=(S*A-u*R-p*D)*T,r[7]=(o*R-f*A+x*D)*T,r[8]=(c*X-a*L+m*b)*T,r[9]=(s*L-e*X-n*b)*T,r[10]=(u*M-g*A+p*P)*T,r[11]=(l*A-o*M-x*P)*T,r[12]=(a*C-c*k-h*b)*T,r[13]=(e*k-s*C+i*b)*T,r[14]=(g*D-u*y-S*P)*T,r[15]=(o*y-l*D+f*P)*T,r):null}function it(r,t,e){var s=e[0],i=e[1],n=e[2],c,a,h,m,o,l,f,x,u,g,S,p;return t===r?(r[12]=t[0]*s+t[4]*i+t[8]*n+t[12],r[13]=t[1]*s+t[5]*i+t[9]*n+t[13],r[14]=t[2]*s+t[6]*i+t[10]*n+t[14],r[15]=t[3]*s+t[7]*i+t[11]*n+t[15]):(c=t[0],a=t[1],h=t[2],m=t[3],o=t[4],l=t[5],f=t[6],x=t[7],u=t[8],g=t[9],S=t[10],p=t[11],r[0]=c,r[1]=a,r[2]=h,r[3]=m,r[4]=o,r[5]=l,r[6]=f,r[7]=x,r[8]=u,r[9]=g,r[10]=S,r[11]=p,r[12]=c*s+o*i+u*n+t[12],r[13]=a*s+l*i+g*n+t[13],r[14]=h*s+f*i+S*n+t[14],r[15]=m*s+x*i+p*n+t[15]),r}function nt(r,t,e){var s=Math.sin(e),i=Math.cos(e),n=t[4],c=t[5],a=t[6],h=t[7],m=t[8],o=t[9],l=t[10],f=t[11];return t!==r&&(r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3],r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15]),r[4]=n*i+m*s,r[5]=c*i+o*s,r[6]=a*i+l*s,r[7]=h*i+f*s,r[8]=m*i-n*s,r[9]=o*i-c*s,r[10]=l*i-a*s,r[11]=f*i-h*s,r}function ct(r,t,e){var s=Math.sin(e),i=Math.cos(e),n=t[0],c=t[1],a=t[2],h=t[3],m=t[8],o=t[9],l=t[10],f=t[11];return t!==r&&(r[4]=t[4],r[5]=t[5],r[6]=t[6],r[7]=t[7],r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15]),r[0]=n*i-m*s,r[1]=c*i-o*s,r[2]=a*i-l*s,r[3]=h*i-f*s,r[8]=n*s+m*i,r[9]=c*s+o*i,r[10]=a*s+l*i,r[11]=h*s+f*i,r}function V(r,t,e,s){var i=t[0],n=t[1],c=t[2],a=t[3],h=i+i,m=n+n,o=c+c,l=i*h,f=i*m,x=i*o,u=n*m,g=n*o,S=c*o,p=a*h,P=a*m,D=a*o,A=s[0],y=s[1],M=s[2];return r[0]=(1-(u+S))*A,r[1]=(f+D)*A,r[2]=(x-P)*A,r[3]=0,r[4]=(f-D)*y,r[5]=(1-(l+S))*y,r[6]=(g+p)*y,r[7]=0,r[8]=(x+P)*M,r[9]=(g-p)*M,r[10]=(1-(l+u))*M,r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r}function w(){var r=new z(3);return z!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function W(r){var t=new z(3);return t[0]=r[0],t[1]=r[1],t[2]=r[2],t}function Z(r){var t=r[0],e=r[1],s=r[2];return Math.sqrt(t*t+e*e+s*s)}function v(r,t,e){var s=new z(3);return s[0]=r,s[1]=t,s[2]=e,s}function at(r,t,e){return r[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],r}function E(r,t,e,s){return r[0]=t[0]+e[0]*s,r[1]=t[1]+e[1]*s,r[2]=t[2]+e[2]*s,r}function j(r,t){var e=t[0],s=t[1],i=t[2],n=e*e+s*s+i*i;return n>0&&(n=1/Math.sqrt(n)),r[0]=t[0]*n,r[1]=t[1]*n,r[2]=t[2]*n,r}function ht(r,t,e){var s=t[0],i=t[1],n=t[2],c=e[3]*s+e[7]*i+e[11]*n+e[15];return c=c||1,r[0]=(e[0]*s+e[4]*i+e[8]*n+e[12])/c,r[1]=(e[1]*s+e[5]*i+e[9]*n+e[13])/c,r[2]=(e[2]*s+e[6]*i+e[10]*n+e[14])/c,r}function U(r,t,e){var s=t[0],i=t[1],n=t[2];return r[0]=s*e[0]+i*e[3]+n*e[6],r[1]=s*e[1]+i*e[4]+n*e[7],r[2]=s*e[2]+i*e[5]+n*e[8],r}(function(){var r=w();return function(t,e,s,i,n,c){var a,h;for(e||(e=3),s||(s=0),i?h=Math.min(i*e+s,t.length):h=t.length,a=s;a<h;a+=e)r[0]=t[a],r[1]=t[a+1],r[2]=t[a+2],n(r,r,c),t[a]=r[0],t[a+1]=r[1],t[a+2]=r[2];return t}})();class ot{orbitCentre;cameraDistance;cameraTransform;pitch;yaw;constructor(){this.orbitCentre=N(),this.cameraDistance=3,this.pitch=0,this.yaw=0,this.cameraTransform=N(),this.updateCameraTransform()}rotateCamera(t,e){this.pitch=Math.min(Math.max(this.pitch+t,-Math.PI/2),Math.PI/2),this.yaw+=e,this.updateCameraTransform()}getAngles(){return[this.pitch,this.yaw]}getRotationMatrix(t){return t[0]=this.cameraTransform[0],t[1]=this.cameraTransform[1],t[2]=this.cameraTransform[2],t[3]=0,t[4]=this.cameraTransform[4],t[5]=this.cameraTransform[5],t[6]=this.cameraTransform[6],t[7]=0,t[8]=this.cameraTransform[8],t[9]=this.cameraTransform[9],t[10]=this.cameraTransform[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}getCameraPosition(t){return t[0]=this.cameraTransform[12],t[1]=this.cameraTransform[13],t[2]=this.cameraTransform[14],t}getCameraMatrix(t){return st(t,this.cameraTransform),t}setAngles(t,e){this.pitch=Math.min(Math.max(t,-Math.PI/2),Math.PI/2),this.yaw=e,this.updateCameraTransform()}getPosition(t){return t[0]=this.cameraTransform[12],t[1]=this.cameraTransform[13],t[2]=this.cameraTransform[14],t}transformDirection(t,e){const s=this.cameraTransform,i=e[0],n=e[1],c=e[2];return t[0]=s[0]*i+s[4]*n+s[8]*c,t[1]=s[1]*i+s[5]*n+s[9]*c,t[2]=s[2]*i+s[6]*n+s[10]*c,t}updateCameraTransform(){const t=N();ct(t,N(),this.yaw),nt(this.orbitCentre,t,this.pitch),it(this.cameraTransform,this.orbitCentre,v(0,0,Math.abs(this.cameraDistance)))}}class G{transform;constructor(t){this.transform=t}getWorldPosition(){const t=N();return B(t,this.transform),v(t[12],t[13],t[14])}sdf(t){const e=w();return ht(e,t,this.transform),this.localSdf(e)}}class mt extends G{radius;constructor(t,e){super(t),this.radius=e}localSdf(t){return Z(t)-this.radius}getLocalBoundingRadius(){return this.radius}}class lt extends G{halfSize;constructor(t,e){super(t),this.halfSize=W(e)}localSdf(t){const e=v(Math.abs(t[0])-this.halfSize[0],Math.abs(t[1])-this.halfSize[1],Math.abs(t[2])-this.halfSize[2]),s=v(Math.max(e[0],0),Math.max(e[1],0),Math.max(e[2],0)),i=Z(s),n=Math.min(Math.max(e[0],Math.max(e[1],e[2])),0);return i+n}getLocalBoundingRadius(){return Z(this.halfSize)}}class ft extends G{majorRadius;minorRadius;constructor(t,e,s){super(t),this.majorRadius=e,this.minorRadius=s}localSdf(t){const e=t[0],s=t[1],i=t[2],n=Math.sqrt(e*e+i*i)-this.majorRadius,c=s;return Math.sqrt(n*n+c*c)-this.minorRadius}getLocalBoundingRadius(){return this.majorRadius+this.minorRadius}}class d{static createSphere(t,e,s,i){const n=N();V(n,[0,0,0,1],[t,e,s],[1,1,1]);const c=N();return B(c,n),new mt(c,i)}static createBox(t,e,s,i){const n=N();V(n,[0,0,0,1],[t,e,s],[1,1,1]);const c=N();return B(c,n),new lt(c,i)}static createTorus(t,e,s,i){const n=N();V(n,[0,0,0,1],[t,e,s],[1,1,1]);const c=N();return B(c,n),new ft(c,i,i/4)}static presets=[{name:"Sphere",objects:[d.createSphere(0,0,0,1.5)]},{name:"Grid of Spheres",objects:[d.createSphere(-1,-1,0,.3),d.createSphere(0,-1,0,.3),d.createSphere(1,-1,0,.3),d.createSphere(-1,0,0,.3),d.createSphere(0,0,0,.3),d.createSphere(1,0,0,.3),d.createSphere(-1,1,0,.3),d.createSphere(0,1,0,.3),d.createSphere(1,1,0,.3)]},{name:"Atom",objects:[d.createSphere(0,0,0,.5),d.createSphere(1.2,0,0,.3),d.createSphere(-1.2,0,0,.3),d.createSphere(0,1.2,0,.3),d.createSphere(0,-1.2,0,.3),d.createSphere(0,0,1.2,.3),d.createSphere(0,0,-1.2,.3)]},{name:"Random Spheres",objects:[d.createSphere(.8,-.3,.2,.4),d.createSphere(-.5,.9,-.1,.5),d.createSphere(.2,.1,.8,.3),d.createSphere(-.9,-.4,-.6,.6),d.createSphere(.4,-.8,.5,.35),d.createSphere(-.2,.6,-.9,.4),d.createSphere(.7,.3,-.4,.25)]},{name:"Cube",objects:[d.createBox(0,0,0,v(1,1,1))]},{name:"Sphere and Cube",objects:[d.createSphere(-.7,0,0,.5),d.createBox(1,0,0,v(.5,.5,.5))]},{name:"Pyramid of Boxes",objects:[d.createBox(0,-.5,0,v(.9,.25,.9)),d.createBox(0,0,0,v(.6,.25,.6)),d.createBox(0,.5,0,v(.3,.25,.3))]},{name:"Torus",objects:[d.createTorus(0,0,0,1.3)]},{name:"Dense Sphere Grid",objects:(()=>{const t=[];for(let n=0;n<5;n++)for(let c=0;c<5;c++)for(let a=0;a<5;a++)t.push(d.createSphere(n*.6-1.2,c*.6-1.2,a*.6-1.2,.15));return t})()}];static getPreset(t){return this.presets[Math.max(0,Math.min(t,this.presets.length-1))]}static getPresetCount(){return this.presets.length}static populateSceneDropdown(t,e=0){t.innerHTML="";for(let s=0;s<this.presets.length;s++){const i=this.getPreset(s),n=document.createElement("option");n.value=s.toString(),n.textContent=i.name,n.selected=s===e,t.appendChild(n)}}}class I{min;max;constructor(t,e){this.min=W(t),this.max=W(e)}contains(t){return t[0]>=this.min[0]&&t[0]<=this.max[0]&&t[1]>=this.min[1]&&t[1]<=this.max[1]&&t[2]>=this.min[2]&&t[2]<=this.max[2]}intersects(t){return this.min[0]<=t.max[0]&&this.max[0]>=t.min[0]&&this.min[1]<=t.max[1]&&this.max[1]>=t.min[1]&&this.min[2]<=t.max[2]&&this.max[2]>=t.min[2]}distanceToBox(t){let e=0;this.max[0]<t.min[0]?e=t.min[0]-this.max[0]:t.max[0]<this.min[0]&&(e=this.min[0]-t.max[0]);let s=0;this.max[1]<t.min[1]?s=t.min[1]-this.max[1]:t.max[1]<this.min[1]&&(s=this.min[1]-t.max[1]);let i=0;return this.max[2]<t.min[2]?i=t.min[2]-this.max[2]:t.max[2]<this.min[2]&&(i=this.min[2]-t.max[2]),Math.hypot(e,s,i)}center(){return v((this.min[0]+this.max[0])/2,(this.min[1]+this.max[1])/2,(this.min[2]+this.max[2])/2)}merge(t){return new I(v(Math.min(this.min[0],t.min[0]),Math.min(this.min[1],t.min[1]),Math.min(this.min[2],t.min[2])),v(Math.max(this.max[0],t.max[0]),Math.max(this.max[1],t.max[1]),Math.max(this.max[2],t.max[2])))}static fromPrimitive(t){const e=t.getWorldPosition(),s=t.getLocalBoundingRadius(),i=N(),c=B(i,t.transform)?i:t.transform,a=Math.hypot(c[0],c[1],c[2]),h=Math.hypot(c[4],c[5],c[6]),m=Math.hypot(c[8],c[9],c[10]),o=Math.max(a,h,m),l=s*o*1.5;return new I(v(e[0]-l,e[1]-l,e[2]-l),v(e[0]+l,e[1]+l,e[2]+l))}}function F(r){if(r.length===0)return new I(v(0,0,0),v(0,0,0));let t=I.fromPrimitive(r[0]);for(let e=1;e<r.length;e++)t=t.merge(I.fromPrimitive(r[e]));return t}class Q{bounds;primitives;children;level;isEmpty;minDistance;constructor(t,e,s){this.bounds=t,this.primitives=e,this.children=null,this.level=s,this.isEmpty=!0,this.minDistance=0}isLeaf(){return this.children===null}}class dt{root;maxDepth;maxPrimitivesPerNode;primitives;sceneBounds;primitiveBounds;constructor(t,e,s=6,i=4){this.maxDepth=s,this.maxPrimitivesPerNode=i,this.primitives=t,this.sceneBounds=e,this.primitiveBounds=t.map(n=>I.fromPrimitive(n)),this.root=this.buildNode(t,e,0),this.computeMinDistances(this.root)}buildNode(t,e,s){const i=new Q(e,[],s);if(s>=this.maxDepth||t.length<=this.maxPrimitivesPerNode)return i.primitives=t,i;const n=e.center(),c=[];for(let h=0;h<2;h++)for(let m=0;m<2;m++)for(let o=0;o<2;o++){const l=o===0?e.min[0]:n[0],f=o===0?n[0]:e.max[0],x=m===0?e.min[1]:n[1],u=m===0?n[1]:e.max[1],g=h===0?e.min[2]:n[2],S=h===0?n[2]:e.max[2];c.push(new I(v(l,x,g),v(f,u,S)))}const a=Array.from({length:8},()=>[]);for(const h of t){const m=I.fromPrimitive(h);for(let o=0;o<8;o++)c[o].intersects(m)&&a[o].push(h)}i.children=[];for(let h=0;h<8;h++)if(a[h].length>0)i.children.push(this.buildNode(a[h],c[h],s+1));else{const m=new Q(c[h],[],s+1);i.children.push(m)}return i}getPrimitivesAt(t){const e=new Set;return this.queryNode(this.root,t,e),Array.from(e)}queryNode(t,e,s){if(t.bounds.contains(e)){if(t.isLeaf()){for(const i of t.primitives)s.add(i);return}if(t.children)for(const i of t.children)this.queryNode(i,e,s)}}computeMinDistances(t){if(t.isLeaf()){const s=t.primitives.length>0;if(t.isEmpty=!s,s)t.minDistance=0;else{let i=1/0;for(let n=0;n<this.primitiveBounds.length;n++){const c=t.bounds.distanceToBox(this.primitiveBounds[n]);c<i&&(i=c)}t.minDistance=i!==1/0?Math.max(0,i):0}return{hasPrims:s}}let e=!1;if(t.children)for(const s of t.children)this.computeMinDistances(s).hasPrims&&(e=!0);if(t.isEmpty=!e,t.isEmpty){let s=1/0;for(let i=0;i<this.primitiveBounds.length;i++){const n=t.bounds.distanceToBox(this.primitiveBounds[i]);n<s&&(s=n)}t.minDistance=s!==1/0?Math.max(0,s):0}else t.minDistance=0;return{hasPrims:e}}intersectRayBox(t,e,s){const i=w(),n=w();for(let h=0;h<3;h++){const m=1/e[h];let o=(s.min[h]-t[h])*m,l=(s.max[h]-t[h])*m;m<0&&([o,l]=[l,o]),i[h]=o,n[h]=l}const c=Math.max(i[0],i[1],i[2]),a=Math.min(n[0],n[1],n[2]);return c>a||a<0?null:[Math.max(0,c),a]}findNode(t){return this.findNodeRecursive(this.root,t)}findNodeRecursive(t,e){if(!t.bounds.contains(e))return null;if(t.isLeaf()||t.level===this.maxDepth)return t;if(t.children)for(const s of t.children){const i=this.findNodeRecursive(s,e);if(i)return i}return t}marchRay(t,e,s){const i=w();E(i,t,e,s);const n=this.findNode(i);if(!n)return 0;if(n.isEmpty){const c=this.intersectRayBox(t,e,n.bounds);if(c){const[a,h]=c,m=Math.max(0,h-s),o=Math.max(0,Math.min(m,n.minDistance*.99));return o>0?o+.001:0}}return 0}}class xt{bounds;primitives;left;right;constructor(t,e){this.bounds=t,this.primitives=e,this.left=null,this.right=null}isLeaf(){return this.left===null&&this.right===null}}class ut{root;maxDepth;maxPrimitivesPerNode;constructor(t,e,s=20,i=2){this.maxDepth=s,this.maxPrimitivesPerNode=i;const n=F(t);this.root=this.buildNode(t,n,0)}buildNode(t,e,s){const i=new xt(e,[]);if(s>=this.maxDepth||t.length<=this.maxPrimitivesPerNode)return i.primitives=t,i;const n=w();at(n,e.max,e.min);let c=0;n[1]>n[0]&&(c=1),n[2]>n[c]&&(c=2);const a=[...t].sort((x,u)=>{const g=x.getWorldPosition()[c],S=u.getWorldPosition()[c];return g-S}),h=Math.floor(a.length/2),m=a.slice(0,h),o=a.slice(h);if(m.length===0||o.length===0)return i.primitives=t,i;const l=F(m),f=F(o);return i.left=this.buildNode(m,l,s+1),i.right=this.buildNode(o,f,s+1),i}getPrimitivesAt(t){const e=new Set;return this.queryNode(this.root,t,e),Array.from(e)}queryNode(t,e,s){if(t.bounds.contains(e)){if(t.isLeaf()){for(const i of t.primitives)s.add(i);return}t.left&&this.queryNode(t.left,e,s),t.right&&this.queryNode(t.right,e,s)}}}class vt{objectSDFs;camera;octree=null;bvh=null;accelerationStructure="None";currentPresetIndex=0;cachedBounds=null;constructor(t="None"){this.camera=new ot,this.objectSDFs=new Array,this.accelerationStructure=t,this.loadPreset(0)}loadPreset(t){this.currentPresetIndex=Math.max(0,Math.min(t,d.getPresetCount()-1));const e=d.getPreset(this.currentPresetIndex);this.objectSDFs=[...e.objects],this.cachedBounds=null,this.accelerationStructure=="Octree"?(this.buildOctree(),this.bvh=null):this.accelerationStructure=="BVH"?(this.buildBVH(),this.octree=null):(this.octree=null,this.bvh=null)}buildOctree(){const t=this.getSceneBounds();this.octree=new dt(this.objectSDFs,t)}buildBVH(){const t=this.getSceneBounds();this.bvh=new ut(this.objectSDFs,t)}getSceneBounds(){return this.cachedBounds||(this.cachedBounds=this.calculateSceneBounds()),this.cachedBounds}calculateSceneBounds(){return new I(v(-10,-10,-10),v(10,10,10))}nextPreset(){this.loadPreset(Math.min(this.currentPresetIndex+1,d.getPresetCount()))}previousPreset(){this.loadPreset(Math.max(this.currentPresetIndex-1,0))}getCurrentPresetInfo(){const t=d.getPreset(this.currentPresetIndex);return{index:this.currentPresetIndex,name:t.name,total:d.getPresetCount()}}getDistance(t,e){let i=10;if(this.accelerationStructure==="Octree"&&this.octree){const n=this.octree.findNode(t);if(n){if(n.primitives.length>0)for(const c of n.primitives)e&&e.count++,i=Math.min(c.sdf(t),i);else n.isEmpty&&(i=Math.min(i,n.minDistance*.99));return i}for(const c of this.objectSDFs)e&&e.count++,i=Math.min(c.sdf(t),i)}else if(this.accelerationStructure==="BVH"&&this.bvh){const n=this.bvh.getPrimitivesAt(t);if(n.length==0)return .2;for(const c of n)e&&e.count++,i=Math.min(c.sdf(t),i)}else for(const n of this.objectSDFs)e&&e.count++,i=Math.min(n.sdf(t),i);return i}}class J{}const pt=100,K=10,yt=.001;class _ extends J{runRaymarcher(t,e,s,i,n,c,a,h,m=0,o=a){const l=t.camera.getRotationMatrix(N()),f=Y();$(f,l);const x=w();t.camera.getPosition(x);for(let u=m;u<o;u++){const g=u-m,S=(u/a-.5)*2;for(let p=0;p<c;p++){const P=g*c+p,D=P*3;i[P]=0,n[P]=0;const A=(p/c-.5)*2,y=v(A,S,-1);U(y,y,f),j(y,y);const M=this.rayMarch(t,x,y,P,i,n),R=w();E(R,x,y,M);let b;M>=K?b=v(0,0,0):b=this.getNormal(t,R,P,i),s[D]=(b[0]+1)*.5*255,s[D+1]=(b[1]+1)*.5*255,s[D+2]=(b[2]+1)*.5*255,e[P]=M}}}getSceneDistance(t,e,s,i){const n={count:0},c=t.getDistance(e,n);return i[s]+=n.count,c}getNormal(t,e,s,i){let n=this.getSceneDistance(t,e,s,i);const c=[.01,0,0],a=w();return a[0]=n-this.getSceneDistance(t,v(e[0]-c[0],e[1],e[2]),s,i),a[1]=n-this.getSceneDistance(t,v(e[0],e[1]-c[0],e[2]),s,i),a[2]=n-this.getSceneDistance(t,v(e[0],e[1],e[2]-c[0]),s,i),j(a,a),a}rayMarch(t,e,s,i,n,c){let a=0;for(let h=0;h<pt;h++){const m=w();if(E(m,e,s,a),t.accelerationStructure==="Octree"&&t.octree){const l=t.octree.marchRay(e,s,a);if(l>0){if(a+=l,a>K)break;continue}}const o=this.getSceneDistance(t,m,i,n);if(a+=o,c[i]+=1,o<yt||a>K)break}return a}}const St=200,O=10,Pt=.001,gt=.1;class bt extends J{runRaymarcher(t,e,s,i,n,c,a,h,m=0,o=a){const l=t.camera.getRotationMatrix(N()),f=Y();$(f,l);const x=w();t.camera.getPosition(x);for(let u=m;u<o;u++){const g=u-m,S=(u/a-.5)*2;for(let p=0;p<c;p++){const P=g*c+p,D=P*3;i[P]=0,n[P]=0;const A=(p/c-.5)*2,y=v(A,S,-1);U(y,y,f),j(y,y);const M=this.fixedStepMarch(t,x,y,P,i,n),R=w();E(R,x,y,M);let b;M>=O?b=v(0,0,0):b=this.getNormal(t,R,P,i),s[D]=(b[0]+1)*.5*255,s[D+1]=(b[1]+1)*.5*255,s[D+2]=(b[2]+1)*.5*255,e[P]=M}}}getSceneDistance(t,e,s,i){const n={count:0},c=t.getDistance(e,n);return i[s]+=n.count,c}getNormal(t,e,s,i){let n=this.getSceneDistance(t,e,s,i);const c=[.01,0,0],a=w();return a[0]=n-this.getSceneDistance(t,v(e[0]-c[0],e[1],e[2]),s,i),a[1]=n-this.getSceneDistance(t,v(e[0],e[1]-c[0],e[2]),s,i),a[2]=n-this.getSceneDistance(t,v(e[0],e[1],e[2]-c[0]),s,i),j(a,a),a}fixedStepMarch(t,e,s,i,n,c){let a=0,h=!1;for(let m=0;m<St;m++){const o=w();if(E(o,e,s,a),t.accelerationStructure==="Octree"&&t.octree){const f=t.octree.marchRay(e,s,a);if(f>0){if(a+=f,a>O)break;continue}}const l=this.getSceneDistance(t,o,i,n);if(c[i]+=1,l<Pt){h=!0;break}if(a+=gt,a>O)break}return h?a:O}}const Mt=200,H=10,Dt=.001,tt=.1,Tt=.8,et=tt*.25,rt=tt*5,wt=.1,Nt=.01;class At extends J{runRaymarcher(t,e,s,i,n,c,a,h,m=0,o=a){const l=t.camera.getRotationMatrix(N()),f=Y();$(f,l);const x=w();t.camera.getPosition(x);for(let u=m;u<o;u++){const g=u-m,S=(u/a-.5)*2;for(let p=0;p<c;p++){const P=g*c+p,D=P*3;i[P]=0,n[P]=0;const A=(p/c-.5)*2,y=v(A,S,-1);U(y,y,f),j(y,y);const M=this.adaptiveStepMarch(t,x,y,P,i,n),R=w();E(R,x,y,M);let b;M>=H?b=v(0,0,0):b=this.getNormal(t,R,P,i),s[D]=(b[0]+1)*.5*255,s[D+1]=(b[1]+1)*.5*255,s[D+2]=(b[2]+1)*.5*255,e[P]=M}}}getSceneDistance(t,e,s,i){const n={count:0},c=t.getDistance(e,n);return i[s]+=n.count,c}getNormal(t,e,s,i){let n=this.getSceneDistance(t,e,s,i);const c=[.01,0,0],a=w();return a[0]=n-this.getSceneDistance(t,v(e[0]-c[0],e[1],e[2]),s,i),a[1]=n-this.getSceneDistance(t,v(e[0],e[1]-c[0],e[2]),s,i),a[2]=n-this.getSceneDistance(t,v(e[0],e[1],e[2]-c[0]),s,i),j(a,a),a}adaptiveStepMarch(t,e,s,i,n,c){let a=0,h=!1;for(let m=0;m<Mt;m++){const o=w();if(E(o,e,s,a),t.accelerationStructure==="Octree"&&t.octree){const x=t.octree.marchRay(e,s,a);if(x>0){if(a+=x,a>H)break;continue}}const l=this.getSceneDistance(t,o,i,n);if(c[i]+=1,l<Dt){h=!0;break}let f;if(l<wt?f=Nt:(f=Tt*l,f<et&&(f=et),f>rt&&(f=rt)),a+=f,a>H)break}return h?a:H}}self.onmessage=r=>{const{width:t,height:e,time:s,yStart:i,yEnd:n,camera:c,algorithm:a,scenePresetIndex:h,accelerationStructure:m}=r.data,o=new vt(m);o.loadPreset(h),o.camera.setAngles(c.pitch,c.yaw);const l=Math.max(0,n-i),f=new Uint8ClampedArray(t*l),x=new Uint8ClampedArray(t*l*3),u=new Uint16Array(t*l),g=new Uint16Array(t*l);let S;switch(a){case"sphere-tracer":S=new _;break;case"fixed-step":S=new bt;break;case"adaptive-step":S=new At;break;default:S=new _}S.runRaymarcher(o,f,x,u,g,t,e,s,i,n);const p={yStart:i,yEnd:n,depth:f,normal:x,sdfEval:u,iters:g};self.postMessage(p,[f.buffer,x.buffer,u.buffer,g.buffer])}})();
