(function(){"use strict";var I=typeof Float32Array<"u"?Float32Array:Array;function $(){var s=new I(9);return I!=Float32Array&&(s[1]=0,s[2]=0,s[3]=0,s[5]=0,s[6]=0,s[7]=0),s[0]=1,s[4]=1,s[8]=1,s}function U(s,t){return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[4],s[4]=t[5],s[5]=t[6],s[6]=t[8],s[7]=t[9],s[8]=t[10],s}function R(){var s=new I(16);return I!=Float32Array&&(s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0),s[0]=1,s[5]=1,s[10]=1,s[15]=1,s}function rt(s,t){return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3],s[4]=t[4],s[5]=t[5],s[6]=t[6],s[7]=t[7],s[8]=t[8],s[9]=t[9],s[10]=t[10],s[11]=t[11],s[12]=t[12],s[13]=t[13],s[14]=t[14],s[15]=t[15],s}function E(s,t){var e=t[0],r=t[1],i=t[2],n=t[3],c=t[4],a=t[5],h=t[6],m=t[7],o=t[8],f=t[9],x=t[10],u=t[11],p=t[12],b=t[13],y=t[14],v=t[15],g=e*a-r*c,w=e*h-i*c,N=e*m-n*c,P=r*h-i*a,D=r*m-n*a,B=i*m-n*h,S=o*b-f*p,k=o*y-x*p,C=o*v-u*p,X=f*y-x*b,q=f*v-u*b,O=x*v-u*y,M=g*O-w*q+N*X+P*C-D*k+B*S;return M?(M=1/M,s[0]=(a*O-h*q+m*X)*M,s[1]=(i*q-r*O-n*X)*M,s[2]=(b*B-y*D+v*P)*M,s[3]=(x*D-f*B-u*P)*M,s[4]=(h*C-c*O-m*k)*M,s[5]=(e*O-i*C+n*k)*M,s[6]=(y*N-p*B-v*w)*M,s[7]=(o*B-x*N+u*w)*M,s[8]=(c*q-a*C+m*S)*M,s[9]=(r*C-e*q-n*S)*M,s[10]=(p*D-b*N+v*g)*M,s[11]=(f*N-o*D-u*g)*M,s[12]=(a*k-c*X-h*S)*M,s[13]=(e*X-r*k+i*S)*M,s[14]=(b*w-p*P-y*g)*M,s[15]=(o*P-f*w+x*g)*M,s):null}function it(s,t,e){var r=e[0],i=e[1],n=e[2],c,a,h,m,o,f,x,u,p,b,y,v;return t===s?(s[12]=t[0]*r+t[4]*i+t[8]*n+t[12],s[13]=t[1]*r+t[5]*i+t[9]*n+t[13],s[14]=t[2]*r+t[6]*i+t[10]*n+t[14],s[15]=t[3]*r+t[7]*i+t[11]*n+t[15]):(c=t[0],a=t[1],h=t[2],m=t[3],o=t[4],f=t[5],x=t[6],u=t[7],p=t[8],b=t[9],y=t[10],v=t[11],s[0]=c,s[1]=a,s[2]=h,s[3]=m,s[4]=o,s[5]=f,s[6]=x,s[7]=u,s[8]=p,s[9]=b,s[10]=y,s[11]=v,s[12]=c*r+o*i+p*n+t[12],s[13]=a*r+f*i+b*n+t[13],s[14]=h*r+x*i+y*n+t[14],s[15]=m*r+u*i+v*n+t[15]),s}function nt(s,t,e){var r=Math.sin(e),i=Math.cos(e),n=t[4],c=t[5],a=t[6],h=t[7],m=t[8],o=t[9],f=t[10],x=t[11];return t!==s&&(s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3],s[12]=t[12],s[13]=t[13],s[14]=t[14],s[15]=t[15]),s[4]=n*i+m*r,s[5]=c*i+o*r,s[6]=a*i+f*r,s[7]=h*i+x*r,s[8]=m*i-n*r,s[9]=o*i-c*r,s[10]=f*i-a*r,s[11]=x*i-h*r,s}function ct(s,t,e){var r=Math.sin(e),i=Math.cos(e),n=t[0],c=t[1],a=t[2],h=t[3],m=t[8],o=t[9],f=t[10],x=t[11];return t!==s&&(s[4]=t[4],s[5]=t[5],s[6]=t[6],s[7]=t[7],s[12]=t[12],s[13]=t[13],s[14]=t[14],s[15]=t[15]),s[0]=n*i-m*r,s[1]=c*i-o*r,s[2]=a*i-f*r,s[3]=h*i-x*r,s[8]=n*r+m*i,s[9]=c*r+o*i,s[10]=a*r+f*i,s[11]=h*r+x*i,s}function at(s,t,e,r){var i=t[0],n=t[1],c=t[2],a=t[3],h=i+i,m=n+n,o=c+c,f=i*h,x=i*m,u=i*o,p=n*m,b=n*o,y=c*o,v=a*h,g=a*m,w=a*o,N=r[0],P=r[1],D=r[2];return s[0]=(1-(p+y))*N,s[1]=(x+w)*N,s[2]=(u-g)*N,s[3]=0,s[4]=(x-w)*P,s[5]=(1-(f+y))*P,s[6]=(b+v)*P,s[7]=0,s[8]=(u+g)*D,s[9]=(b-v)*D,s[10]=(1-(f+p))*D,s[11]=0,s[12]=e[0],s[13]=e[1],s[14]=e[2],s[15]=1,s}function T(){var s=new I(3);return I!=Float32Array&&(s[0]=0,s[1]=0,s[2]=0),s}function V(s){var t=new I(3);return t[0]=s[0],t[1]=s[1],t[2]=s[2],t}function Z(s){var t=s[0],e=s[1],r=s[2];return Math.sqrt(t*t+e*e+r*r)}function d(s,t,e){var r=new I(3);return r[0]=s,r[1]=t,r[2]=e,r}function ht(s,t,e){return s[0]=t[0]-e[0],s[1]=t[1]-e[1],s[2]=t[2]-e[2],s}function z(s,t,e,r){return s[0]=t[0]+e[0]*r,s[1]=t[1]+e[1]*r,s[2]=t[2]+e[2]*r,s}function ot(s,t){var e=t[0]-s[0],r=t[1]-s[1],i=t[2]-s[2];return Math.sqrt(e*e+r*r+i*i)}function j(s,t){var e=t[0],r=t[1],i=t[2],n=e*e+r*r+i*i;return n>0&&(n=1/Math.sqrt(n)),s[0]=t[0]*n,s[1]=t[1]*n,s[2]=t[2]*n,s}function W(s,t,e){var r=t[0],i=t[1],n=t[2],c=e[3]*r+e[7]*i+e[11]*n+e[15];return c=c||1,s[0]=(e[0]*r+e[4]*i+e[8]*n+e[12])/c,s[1]=(e[1]*r+e[5]*i+e[9]*n+e[13])/c,s[2]=(e[2]*r+e[6]*i+e[10]*n+e[14])/c,s}function G(s,t,e){var r=t[0],i=t[1],n=t[2];return s[0]=r*e[0]+i*e[3]+n*e[6],s[1]=r*e[1]+i*e[4]+n*e[7],s[2]=r*e[2]+i*e[5]+n*e[8],s}(function(){var s=T();return function(t,e,r,i,n,c){var a,h;for(e||(e=3),r||(r=0),i?h=Math.min(i*e+r,t.length):h=t.length,a=r;a<h;a+=e)s[0]=t[a],s[1]=t[a+1],s[2]=t[a+2],n(s,s,c),t[a]=s[0],t[a+1]=s[1],t[a+2]=s[2];return t}})();class mt{orbitCentre;cameraDistance;cameraTransform;pitch;yaw;constructor(){this.orbitCentre=R(),this.cameraDistance=3,this.pitch=0,this.yaw=0,this.cameraTransform=R(),this.updateCameraTransform()}rotateCamera(t,e){this.pitch=Math.min(Math.max(this.pitch+t,-Math.PI/2),Math.PI/2),this.yaw+=e,this.updateCameraTransform()}getAngles(){return[this.pitch,this.yaw]}getRotationMatrix(t){return t[0]=this.cameraTransform[0],t[1]=this.cameraTransform[1],t[2]=this.cameraTransform[2],t[3]=0,t[4]=this.cameraTransform[4],t[5]=this.cameraTransform[5],t[6]=this.cameraTransform[6],t[7]=0,t[8]=this.cameraTransform[8],t[9]=this.cameraTransform[9],t[10]=this.cameraTransform[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}getCameraPosition(t){return t[0]=this.cameraTransform[12],t[1]=this.cameraTransform[13],t[2]=this.cameraTransform[14],t}getCameraMatrix(t){return rt(t,this.cameraTransform),t}setAngles(t,e){this.pitch=Math.min(Math.max(t,-Math.PI/2),Math.PI/2),this.yaw=e,this.updateCameraTransform()}getPosition(t){return t[0]=this.cameraTransform[12],t[1]=this.cameraTransform[13],t[2]=this.cameraTransform[14],t}transformDirection(t,e){const r=this.cameraTransform,i=e[0],n=e[1],c=e[2];return t[0]=r[0]*i+r[4]*n+r[8]*c,t[1]=r[1]*i+r[5]*n+r[9]*c,t[2]=r[2]*i+r[6]*n+r[10]*c,t}updateCameraTransform(){const t=R();ct(t,R(),this.yaw),nt(this.orbitCentre,t,this.pitch),it(this.cameraTransform,this.orbitCentre,d(0,0,Math.abs(this.cameraDistance)))}}class L{transform;constructor(t){this.transform=t}getWorldPosition(){const t=R();return E(t,this.transform),d(t[12],t[13],t[14])}sdf(t){const e=T();return W(e,t,this.transform),this.localSdf(e)}}class lt extends L{radius;constructor(t,e){super(t),this.radius=e}localSdf(t){return Z(t)-this.radius}getLocalBoundingRadius(){return this.radius}}class ft extends L{halfSize;constructor(t,e){super(t),this.halfSize=V(e)}localSdf(t){const e=d(Math.abs(t[0])-this.halfSize[0],Math.abs(t[1])-this.halfSize[1],Math.abs(t[2])-this.halfSize[2]),r=d(Math.max(e[0],0),Math.max(e[1],0),Math.max(e[2],0)),i=Z(r),n=Math.min(Math.max(e[0],Math.max(e[1],e[2])),0);return i+n}getLocalBoundingRadius(){return Z(this.halfSize)}}class dt extends L{majorRadius;minorRadius;constructor(t,e,r){super(t),this.majorRadius=e,this.minorRadius=r}localSdf(t){const e=t[0],r=t[1],i=t[2],n=Math.sqrt(e*e+i*i)-this.majorRadius,c=r;return Math.sqrt(n*n+c*c)-this.minorRadius}getLocalBoundingRadius(){return this.majorRadius+this.minorRadius}}class xt extends L{prim1;prim2;smoothness;constructor(t,e,r){super(R()),this.prim1=t,this.prim2=e,this.smoothness=r}localSdf(t){const e=T(),r=R();E(r,this.transform),W(e,t,r);const i=this.prim1.sdf(e),n=this.prim2.sdf(e),c=this.smoothness*4,a=Math.max(c-Math.abs(i-n),0);return Math.min(i,n)-a*a*.25/c}getLocalBoundingRadius(){const t=this.prim1.getLocalBoundingRadius(),e=this.prim2.getLocalBoundingRadius(),r=this.prim1.getWorldPosition(),i=this.prim2.getWorldPosition(),n=ot(r,i);return Math.max(t,e)+n*.5}}class ut extends L{primitive;twistAmount;constructor(t,e=10){super(R()),this.primitive=t,this.twistAmount=e}localSdf(t){const e=T(),r=R();E(r,this.transform),W(e,t,r);const i=this.twistAmount,n=Math.cos(i*e[1]),c=Math.sin(i*e[1]),a=d(n*e[0]-c*e[2],e[1],c*e[0]+n*e[2]);return this.primitive.sdf(a)}getLocalBoundingRadius(){return this.primitive.getLocalBoundingRadius()}}class pt extends L{primitive;radius;constructor(t,e){super(R()),this.primitive=t,this.radius=e}localSdf(t){const e=T(),r=R();return E(r,this.transform),W(e,t,r),this.primitive.sdf(e)-this.radius}getLocalBoundingRadius(){return this.primitive.getLocalBoundingRadius()+this.radius}}class l{static getTransform(t,e,r){const i=R();at(i,[0,0,0,1],[t,e,r],[1,1,1]);const n=R();return E(n,i),n}static createSphere(t,e,r,i){return new lt(l.getTransform(t,e,r),i)}static createBox(t,e,r,i){return new ft(l.getTransform(t,e,r),i)}static createTorus(t,e,r,i){return new dt(l.getTransform(t,e,r),i,i/4)}static createSmoothUnion(t,e,r){return new xt(t,e,r)}static createTwist(t,e){return new ut(t,e)}static createRound(t,e){return new pt(t,e)}static presets=[{name:"Sphere",objects:[l.createSphere(0,0,0,1.5)]},{name:"Grid of Spheres",objects:[l.createSphere(-1,-1,0,.3),l.createSphere(0,-1,0,.3),l.createSphere(1,-1,0,.3),l.createSphere(-1,0,0,.3),l.createSphere(0,0,0,.3),l.createSphere(1,0,0,.3),l.createSphere(-1,1,0,.3),l.createSphere(0,1,0,.3),l.createSphere(1,1,0,.3)]},{name:"Atom",objects:[l.createSphere(0,0,0,.5),l.createSphere(1.2,0,0,.3),l.createSphere(-1.2,0,0,.3),l.createSphere(0,1.2,0,.3),l.createSphere(0,-1.2,0,.3),l.createSphere(0,0,1.2,.3),l.createSphere(0,0,-1.2,.3)]},{name:"Random Spheres",objects:[l.createSphere(.8,-.3,.2,.4),l.createSphere(-.5,.9,-.1,.5),l.createSphere(.2,.1,.8,.3),l.createSphere(-.9,-.4,-.6,.6),l.createSphere(.4,-.8,.5,.35),l.createSphere(-.2,.6,-.9,.4),l.createSphere(.7,.3,-.4,.25)]},{name:"Cube",objects:[l.createBox(0,0,0,d(1,1,1))]},{name:"Sphere and Cube",objects:[l.createSphere(-.7,0,0,.5),l.createBox(1,0,0,d(.5,.5,.5))]},{name:"Pyramid of Boxes",objects:[l.createBox(0,-.5,0,d(.9,.25,.9)),l.createBox(0,0,0,d(.6,.25,.6)),l.createBox(0,.5,0,d(.3,.25,.3))]},{name:"Torus",objects:[l.createTorus(0,0,0,1.3)]},{name:"Dense Sphere Grid",objects:(()=>{const t=[];for(let n=0;n<5;n++)for(let c=0;c<5;c++)for(let a=0;a<5;a++)t.push(l.createSphere(n*.6-1.2,c*.6-1.2,a*.6-1.2,.15));return t})()},{name:"Smooth Union",objects:[l.createSmoothUnion(l.createSphere(0,0,0,.5),l.createBox(0,.5,0,d(1,.2,1)),.2)]},{name:"Rounded Box",objects:[l.createRound(l.createBox(0,0,0,d(.4,.4,.4)),.3)]},{name:"Screw",objects:[l.createRound(l.createTwist(l.createBox(0,0,0,d(.4,1.5,.4)),4),.1)]},{name:"Chicken",objects:[l.createBox(0,0,0,d(.6,.6,.8)),l.createBox(0,-.2,0,d(.8,.4,.6)),l.createBox(0,-.8,.8,d(.4,.6,.3)),l.createBox(0,-.8,1.2,d(.4,.2,.2)),l.createBox(0,-.4,1,d(.2,.2,.2)),l.createBox(.3,1,0,d(.1,.6,.01)),l.createBox(-.3,1,0,d(.1,.6,.01)),l.createBox(0,1.6,.2,d(.6,.01,.2)),l.createBox(.3,1.6,.5,d(.1,.01,.1)),l.createBox(-.3,1.6,.5,d(.1,.01,.1))]}];static getPreset(t){return this.presets[Math.max(0,Math.min(t,this.presets.length-1))]}static getPresetCount(){return this.presets.length}static populateSceneDropdown(t,e=0){t.innerHTML="";for(let r=0;r<this.presets.length;r++){const i=this.getPreset(r),n=document.createElement("option");n.value=r.toString(),n.textContent=i.name,n.selected=r===e,t.appendChild(n)}}}class A{min;max;constructor(t,e){this.min=V(t),this.max=V(e)}contains(t){return t[0]>=this.min[0]&&t[0]<=this.max[0]&&t[1]>=this.min[1]&&t[1]<=this.max[1]&&t[2]>=this.min[2]&&t[2]<=this.max[2]}intersects(t){return this.min[0]<=t.max[0]&&this.max[0]>=t.min[0]&&this.min[1]<=t.max[1]&&this.max[1]>=t.min[1]&&this.min[2]<=t.max[2]&&this.max[2]>=t.min[2]}distanceToBox(t){let e=0;this.max[0]<t.min[0]?e=t.min[0]-this.max[0]:t.max[0]<this.min[0]&&(e=this.min[0]-t.max[0]);let r=0;this.max[1]<t.min[1]?r=t.min[1]-this.max[1]:t.max[1]<this.min[1]&&(r=this.min[1]-t.max[1]);let i=0;return this.max[2]<t.min[2]?i=t.min[2]-this.max[2]:t.max[2]<this.min[2]&&(i=this.min[2]-t.max[2]),Math.hypot(e,r,i)}center(){return d((this.min[0]+this.max[0])/2,(this.min[1]+this.max[1])/2,(this.min[2]+this.max[2])/2)}merge(t){return new A(d(Math.min(this.min[0],t.min[0]),Math.min(this.min[1],t.min[1]),Math.min(this.min[2],t.min[2])),d(Math.max(this.max[0],t.max[0]),Math.max(this.max[1],t.max[1]),Math.max(this.max[2],t.max[2])))}static fromPrimitive(t){const e=t.getWorldPosition(),r=t.getLocalBoundingRadius(),i=R(),c=E(i,t.transform)?i:t.transform,a=Math.hypot(c[0],c[1],c[2]),h=Math.hypot(c[4],c[5],c[6]),m=Math.hypot(c[8],c[9],c[10]),o=Math.max(a,h,m),f=r*o*1.5;return new A(d(e[0]-f,e[1]-f,e[2]-f),d(e[0]+f,e[1]+f,e[2]+f))}}function F(s){if(s.length===0)return new A(d(0,0,0),d(0,0,0));let t=A.fromPrimitive(s[0]);for(let e=1;e<s.length;e++)t=t.merge(A.fromPrimitive(s[e]));return t}class Q{bounds;primitives;children;level;isEmpty;minDistance;constructor(t,e,r){this.bounds=t,this.primitives=e,this.children=null,this.level=r,this.isEmpty=!0,this.minDistance=0}isLeaf(){return this.children===null}}class vt{root;maxDepth;maxPrimitivesPerNode;primitives;sceneBounds;primitiveBounds;constructor(t,e,r=6,i=4){this.maxDepth=r,this.maxPrimitivesPerNode=i,this.primitives=t,this.sceneBounds=e,this.primitiveBounds=t.map(n=>A.fromPrimitive(n)),this.root=this.buildNode(t,e,0),this.computeMinDistances(this.root)}buildNode(t,e,r){const i=new Q(e,[],r);if(r>=this.maxDepth||t.length<=this.maxPrimitivesPerNode)return i.primitives=t,i;const n=e.center(),c=[];for(let h=0;h<2;h++)for(let m=0;m<2;m++)for(let o=0;o<2;o++){const f=o===0?e.min[0]:n[0],x=o===0?n[0]:e.max[0],u=m===0?e.min[1]:n[1],p=m===0?n[1]:e.max[1],b=h===0?e.min[2]:n[2],y=h===0?n[2]:e.max[2];c.push(new A(d(f,u,b),d(x,p,y)))}const a=Array.from({length:8},()=>[]);for(const h of t){const m=A.fromPrimitive(h);for(let o=0;o<8;o++)c[o].intersects(m)&&a[o].push(h)}i.children=[];for(let h=0;h<8;h++)if(a[h].length>0)i.children.push(this.buildNode(a[h],c[h],r+1));else{const m=new Q(c[h],[],r+1);i.children.push(m)}return i}getPrimitivesAt(t){const e=new Set;return this.queryNode(this.root,t,e),Array.from(e)}queryNode(t,e,r){if(t.bounds.contains(e)){if(t.isLeaf()){for(const i of t.primitives)r.add(i);return}if(t.children)for(const i of t.children)this.queryNode(i,e,r)}}computeMinDistances(t){if(t.isLeaf()){const r=t.primitives.length>0;if(t.isEmpty=!r,r)t.minDistance=0;else{let i=1/0;for(let n=0;n<this.primitiveBounds.length;n++){const c=t.bounds.distanceToBox(this.primitiveBounds[n]);c<i&&(i=c)}t.minDistance=i!==1/0?Math.max(0,i):0}return{hasPrims:r}}let e=!1;if(t.children)for(const r of t.children)this.computeMinDistances(r).hasPrims&&(e=!0);if(t.isEmpty=!e,t.isEmpty){let r=1/0;for(let i=0;i<this.primitiveBounds.length;i++){const n=t.bounds.distanceToBox(this.primitiveBounds[i]);n<r&&(r=n)}t.minDistance=r!==1/0?Math.max(0,r):0}else t.minDistance=0;return{hasPrims:e}}intersectRayBox(t,e,r){const i=T(),n=T();for(let h=0;h<3;h++){const m=1/e[h];let o=(r.min[h]-t[h])*m,f=(r.max[h]-t[h])*m;m<0&&([o,f]=[f,o]),i[h]=o,n[h]=f}const c=Math.max(i[0],i[1],i[2]),a=Math.min(n[0],n[1],n[2]);return c>a||a<0?null:[Math.max(0,c),a]}findNode(t){return this.findNodeRecursive(this.root,t)}findNodeRecursive(t,e){if(!t.bounds.contains(e))return null;if(t.isLeaf()||t.level===this.maxDepth)return t;if(t.children)for(const r of t.children){const i=this.findNodeRecursive(r,e);if(i)return i}return t}marchRay(t,e,r){const i=T();z(i,t,e,r);const n=this.findNode(i);if(!n)return 0;if(n.isEmpty){const c=this.intersectRayBox(t,e,n.bounds);if(c){const[a,h]=c,m=Math.max(0,h-r),o=Math.max(0,Math.min(m,n.minDistance*.99));return o>0?o+.001:0}}return 0}}class Pt{bounds;primitives;left;right;constructor(t,e){this.bounds=t,this.primitives=e,this.left=null,this.right=null}isLeaf(){return this.left===null&&this.right===null}}class yt{root;maxDepth;maxPrimitivesPerNode;constructor(t,e,r=20,i=2){this.maxDepth=r,this.maxPrimitivesPerNode=i;const n=F(t);this.root=this.buildNode(t,n,0)}buildNode(t,e,r){const i=new Pt(e,[]);if(r>=this.maxDepth||t.length<=this.maxPrimitivesPerNode)return i.primitives=t,i;const n=T();ht(n,e.max,e.min);let c=0;n[1]>n[0]&&(c=1),n[2]>n[c]&&(c=2);const a=[...t].sort((u,p)=>{const b=u.getWorldPosition()[c],y=p.getWorldPosition()[c];return b-y}),h=Math.floor(a.length/2),m=a.slice(0,h),o=a.slice(h);if(m.length===0||o.length===0)return i.primitives=t,i;const f=F(m),x=F(o);return i.left=this.buildNode(m,f,r+1),i.right=this.buildNode(o,x,r+1),i}getPrimitivesAt(t){const e=new Set;return this.queryNode(this.root,t,e),Array.from(e)}queryNode(t,e,r){if(t.bounds.contains(e)){if(t.isLeaf()){for(const i of t.primitives)r.add(i);return}t.left&&this.queryNode(t.left,e,r),t.right&&this.queryNode(t.right,e,r)}}}class gt{objectSDFs;camera;octree=null;bvh=null;accelerationStructure="None";currentPresetIndex=0;cachedBounds=null;constructor(t="None"){this.camera=new mt,this.objectSDFs=new Array,this.accelerationStructure=t,this.loadPreset(0)}loadPreset(t){this.currentPresetIndex=Math.max(0,Math.min(t,l.getPresetCount()-1));const e=l.getPreset(this.currentPresetIndex);this.objectSDFs=[...e.objects],this.cachedBounds=null,this.accelerationStructure=="Octree"?(this.buildOctree(),this.bvh=null):this.accelerationStructure=="BVH"?(this.buildBVH(),this.octree=null):(this.octree=null,this.bvh=null)}buildOctree(){const t=this.getSceneBounds();this.octree=new vt(this.objectSDFs,t)}buildBVH(){const t=this.getSceneBounds();this.bvh=new yt(this.objectSDFs,t)}getSceneBounds(){return this.cachedBounds||(this.cachedBounds=this.calculateSceneBounds()),this.cachedBounds}calculateSceneBounds(){return new A(d(-10,-10,-10),d(10,10,10))}nextPreset(){this.loadPreset(Math.min(this.currentPresetIndex+1,l.getPresetCount()))}previousPreset(){this.loadPreset(Math.max(this.currentPresetIndex-1,0))}getCurrentPresetInfo(){const t=l.getPreset(this.currentPresetIndex);return{index:this.currentPresetIndex,name:t.name,total:l.getPresetCount()}}getDistance(t,e){let i=10;if(this.accelerationStructure==="Octree"&&this.octree){const n=this.octree.findNode(t);if(n){if(n.primitives.length>0)for(const c of n.primitives)e&&e.count++,i=Math.min(c.sdf(t),i);else n.isEmpty&&(i=Math.min(i,n.minDistance*.99));return i}for(const c of this.objectSDFs)e&&e.count++,i=Math.min(c.sdf(t),i)}else if(this.accelerationStructure==="BVH"&&this.bvh){const n=this.bvh.getPrimitivesAt(t);if(n.length==0)return .2;for(const c of n)e&&e.count++,i=Math.min(c.sdf(t),i)}else for(const n of this.objectSDFs)e&&e.count++,i=Math.min(n.sdf(t),i);return i}}class J{}const bt=100,K=10,St=.001;class _ extends J{runRaymarcher(t,e,r,i,n,c,a,h,m=0,o=a){const f=t.camera.getRotationMatrix(R()),x=$();U(x,f);const u=T();t.camera.getPosition(u);for(let p=m;p<o;p++){const b=p-m,y=(p/a-.5)*2;for(let v=0;v<c;v++){const g=b*c+v,w=g*3;i[g]=0,n[g]=0;const N=(v/c-.5)*2,P=d(N,y,-1);G(P,P,x),j(P,P);const D=this.rayMarch(t,u,P,g,i,n),B=T();z(B,u,P,D);let S;D>=K?S=d(0,0,0):S=this.getNormal(t,B,g,i),r[w]=(S[0]+1)*.5*255,r[w+1]=(S[1]+1)*.5*255,r[w+2]=(S[2]+1)*.5*255,e[g]=D}}}getSceneDistance(t,e,r,i){const n={count:0},c=t.getDistance(e,n);return i[r]+=n.count,c}getNormal(t,e,r,i){let n=this.getSceneDistance(t,e,r,i);const c=[.01,0,0],a=T();return a[0]=n-this.getSceneDistance(t,d(e[0]-c[0],e[1],e[2]),r,i),a[1]=n-this.getSceneDistance(t,d(e[0],e[1]-c[0],e[2]),r,i),a[2]=n-this.getSceneDistance(t,d(e[0],e[1],e[2]-c[0]),r,i),j(a,a),a}rayMarch(t,e,r,i,n,c){let a=0;for(let h=0;h<bt;h++){const m=T();if(z(m,e,r,a),t.accelerationStructure==="Octree"&&t.octree){const f=t.octree.marchRay(e,r,a);if(f>0){if(a+=f,a>K)break;continue}}const o=this.getSceneDistance(t,m,i,n);if(a+=o,c[i]+=1,o<St||a>K)break}return a}}const Tt=200,H=10,Dt=.001,wt=.1;class Mt extends J{runRaymarcher(t,e,r,i,n,c,a,h,m=0,o=a){const f=t.camera.getRotationMatrix(R()),x=$();U(x,f);const u=T();t.camera.getPosition(u);for(let p=m;p<o;p++){const b=p-m,y=(p/a-.5)*2;for(let v=0;v<c;v++){const g=b*c+v,w=g*3;i[g]=0,n[g]=0;const N=(v/c-.5)*2,P=d(N,y,-1);G(P,P,x),j(P,P);const D=this.fixedStepMarch(t,u,P,g,i,n),B=T();z(B,u,P,D);let S;D>=H?S=d(0,0,0):S=this.getNormal(t,B,g,i),r[w]=(S[0]+1)*.5*255,r[w+1]=(S[1]+1)*.5*255,r[w+2]=(S[2]+1)*.5*255,e[g]=D}}}getSceneDistance(t,e,r,i){const n={count:0},c=t.getDistance(e,n);return i[r]+=n.count,c}getNormal(t,e,r,i){let n=this.getSceneDistance(t,e,r,i);const c=[.01,0,0],a=T();return a[0]=n-this.getSceneDistance(t,d(e[0]-c[0],e[1],e[2]),r,i),a[1]=n-this.getSceneDistance(t,d(e[0],e[1]-c[0],e[2]),r,i),a[2]=n-this.getSceneDistance(t,d(e[0],e[1],e[2]-c[0]),r,i),j(a,a),a}fixedStepMarch(t,e,r,i,n,c){let a=0,h=!1;for(let m=0;m<Tt;m++){const o=T();if(z(o,e,r,a),t.accelerationStructure==="Octree"&&t.octree){const x=t.octree.marchRay(e,r,a);if(x>0){if(a+=x,a>H)break;continue}}const f=this.getSceneDistance(t,o,i,n);if(c[i]+=1,f<Dt){h=!0;break}if(a+=wt,a>H)break}return h?a:H}}const Rt=200,Y=10,Nt=.001,tt=.1,Bt=.8,et=tt*.25,st=tt*5,At=.1,It=.01;class zt extends J{runRaymarcher(t,e,r,i,n,c,a,h,m=0,o=a){const f=t.camera.getRotationMatrix(R()),x=$();U(x,f);const u=T();t.camera.getPosition(u);for(let p=m;p<o;p++){const b=p-m,y=(p/a-.5)*2;for(let v=0;v<c;v++){const g=b*c+v,w=g*3;i[g]=0,n[g]=0;const N=(v/c-.5)*2,P=d(N,y,-1);G(P,P,x),j(P,P);const D=this.adaptiveStepMarch(t,u,P,g,i,n),B=T();z(B,u,P,D);let S;D>=Y?S=d(0,0,0):S=this.getNormal(t,B,g,i),r[w]=(S[0]+1)*.5*255,r[w+1]=(S[1]+1)*.5*255,r[w+2]=(S[2]+1)*.5*255,e[g]=D}}}getSceneDistance(t,e,r,i){const n={count:0},c=t.getDistance(e,n);return i[r]+=n.count,c}getNormal(t,e,r,i){let n=this.getSceneDistance(t,e,r,i);const c=[.01,0,0],a=T();return a[0]=n-this.getSceneDistance(t,d(e[0]-c[0],e[1],e[2]),r,i),a[1]=n-this.getSceneDistance(t,d(e[0],e[1]-c[0],e[2]),r,i),a[2]=n-this.getSceneDistance(t,d(e[0],e[1],e[2]-c[0]),r,i),j(a,a),a}adaptiveStepMarch(t,e,r,i,n,c){let a=0,h=!1;for(let m=0;m<Rt;m++){const o=T();if(z(o,e,r,a),t.accelerationStructure==="Octree"&&t.octree){const u=t.octree.marchRay(e,r,a);if(u>0){if(a+=u,a>Y)break;continue}}const f=this.getSceneDistance(t,o,i,n);if(c[i]+=1,f<Nt){h=!0;break}let x;if(f<At?x=It:(x=Bt*f,x<et&&(x=et),x>st&&(x=st)),a+=x,a>Y)break}return h?a:Y}}self.onmessage=s=>{const{width:t,height:e,time:r,yStart:i,yEnd:n,camera:c,algorithm:a,scenePresetIndex:h,accelerationStructure:m}=s.data,o=new gt(m);o.loadPreset(h),o.camera.setAngles(c.pitch,c.yaw);const f=Math.max(0,n-i),x=new Uint8ClampedArray(t*f),u=new Uint8ClampedArray(t*f*3),p=new Uint16Array(t*f),b=new Uint16Array(t*f);let y;switch(a){case"sphere-tracer":y=new _;break;case"fixed-step":y=new Mt;break;case"adaptive-step":y=new zt;break;default:y=new _}y.runRaymarcher(o,x,u,p,b,t,e,r,i,n);const v={yStart:i,yEnd:n,depth:x,normal:u,sdfEval:p,iters:b};self.postMessage(v,[x.buffer,u.buffer,p.buffer,b.buffer])}})();
